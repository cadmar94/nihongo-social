<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nihongo Social Language App</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .app-container {
            max-width: 600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(45deg, #ff6b6b, #feca57);
            padding: 20px;
            text-align: center;
            color: white;
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 8px;
        }
        .filter-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .filter-btn {
    background: none;
    border: none;
    padding: 8px 16px;
    margin: 0 8px;
    cursor: pointer;
    font-size: 14px;
    color: #666;
    text-decoration: none;
    transition: all 0.3s;
}

       .filter-btn:hover {
    color: #333;
    text-decoration: underline;
}

        .filter-btn.active {
    color: #333;
    font-weight: bold;
    text-decoration: none;
}
        .header p {
            opacity: 0.9;
            font-size: 14px;
        }

        .feed {
            padding: 20px;
            max-height: 70vh;
            overflow-y: auto;
        }

        .post {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            border-left: 4px solid #ff6b6b;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .post:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }

        .post-type {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .japanese-text {
            font-size: 20px;
            line-height: 1.6;
            margin-bottom: 15px;
            font-family: 'Hiragino Sans', 'Yu Gothic', sans-serif;
        }

        .reading {
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
            font-style: italic;
        }

        .translation {
            font-size: 16px;
            color: #333;
            margin-bottom: 15px;
        }

        .actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .btn-speak {
            background: #4ecdc4;
            color: white;
        }

        .btn-speak:hover {
            background: #45b7b8;
        }

        .btn-practice {
            background: #feca57;
            color: #333;
        }

        .btn-practice:hover {
            background: #ff9ff3;
        }

        .btn-know {
            background: #48dbfb;
            color: white;
        }

        .btn-know:hover {
            background: #0abde3;
        }

        .btn-difficult {
            background: #ff6b6b;
            color: white;
        }

        .btn-reveal {
            background: #5f27cd;
            color: white;
        }

        .btn-reveal:hover {
            background: #341f97;
        }

        .btn-explain {
            background: #00d2d3;
            color: white;
        }

        .btn-explain:hover {
            background: #01a3a4;
        }

        .quiz-post {
            border-left: 4px solid #9b59b6;
        }

        .quiz-question {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
        }

        .quiz-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }

        .quiz-option {
            padding: 12px 16px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s ease;
            text-align: left;
        }

        .quiz-option:hover {
            border-color: #9b59b6;
            background: #f8f9fa;
        }

        .quiz-option:disabled {
            cursor: not-allowed;
            opacity: 0.8;
        }

        .quiz-feedback {
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-weight: bold;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            padding: 15px;
            background: #f1f2f6;
            margin-top: 20px;
            border-radius: 10px;
        }

        .stat {
            text-align: center;
        }

        .stat-number {
            font-size: 20px;
            font-weight: bold;
            color: #333;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
        }

        .hidden {
            display: none;
        }

        .voice-feedback {
            margin-top: 10px;
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
        }

        .voice-feedback.success {
            background: #d4edda;
            color: #155724;
        }

        .voice-feedback.error {
            background: #f8d7da;
            color: #721c24;
        }

        @media (max-width: 480px) {
            .app-container {
                margin: 10px;
                border-radius: 15px;
            }
            
            .actions {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="header">
            <h1 style="text-align: center; line-height: 1.2; margin-bottom: 5px;">
  日本語フィード<br>
  <span style="font-size: 0.7em;">(Nihongo Feed)</span>
</h1>
        </div>
<div class="filter-container" style="text-align: center; margin: 20px 0; padding: 0 20px;">
            <button class="filter-btn active" onclick="filterPosts('all')">All</button>
            <button class="filter-btn" onclick="filterPosts('daily-life')">Daily Life</button>
            <button class="filter-btn" onclick="filterPosts('food')">Food</button>
            <button class="filter-btn" onclick="filterPosts('casual')">Casual</button>
            <button class="filter-btn" onclick="filterPosts('sumo')">Sumo</button>
        </div>
        <div class="feed" id="feed">
            <!-- Posts will be dynamically generated here -->
        </div>

        <div class="stats">
            <div class="stat">
                <div class="stat-number" id="knownCount">0</div>
                <div class="stat-label">Known</div>
            </div>
            <div class="stat">
                <div class="stat-number" id="practicedCount">0</div>
                <div class="stat-label">Practiced</div>
            </div>
            <div class="stat">
                <div class="stat-number" id="streakCount">1</div>
                <div class="stat-label">Day Streak</div>
            </div>
        </div>
    </div>

    <script>
        // Expanded content library - removed broken quizzes for now
    

// Session-based no-repeat post system
let allLearningPosts = [];
let remainingPosts = [];

// Fetch posts from database
async function fetchPosts() {
    try {
        const response = await fetch('/.netlify/functions/get-posts');
        const data = await response.json();
        allLearningPosts = data || [];
        remainingPosts = [...allLearningPosts]; // Copy all posts to remaining pool
        shuffleArray(remainingPosts);
        console.log(`Loaded ${allLearningPosts.length} posts from database`);
    } catch (error) {
        console.error('Error fetching posts:', error);
        // Keep empty array if fetch fails
        allLearningPosts = [];
        remainingPosts = [];
    }
}

function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

function getNextPost() {
    if (remainingPosts.length === 0) {
        // All posts shown, reshuffle and start over
        remainingPosts = [...allLearningPosts];
        shuffleArray(remainingPosts);
        console.log('All posts shown, reshuffling for new cycle');
    }
    return remainingPosts.pop(); // Remove and return the last post
}

        // Shuffle the posts for randomized order
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }
        // Filter posts by category
        let currentFilter = 'all';

        function filterPosts(category) {
            currentFilter = category;
            
            // Update button active state
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[onclick="filterPosts('${category}')"]`).classList.add('active');
            
            // Clear current feed
            document.getElementById('feed').innerHTML = '';
            
            // Reset post arrays for the new filter
            if (category === 'all') {
                remainingPosts = [...allLearningPosts];
            } else {
                remainingPosts = allLearningPosts.filter(post => {
                    return post.tags && post.tags.includes(category);
                });
            }
            
            shuffleArray(remainingPosts);
            
            // Load first post of filtered category
            loadNextPost();
        }
        // Initialize with shuffled posts
        const learningPosts = shuffleArray(allLearningPosts);

        let currentPostIndex = 0;
        let knownCount = 0;
        let practicedCount = 0;
        let streakCount = 1;

        // Speech synthesis for Japanese pronunciation
        function speakJapanese(text) {
    try {
        if ('speechSynthesis' in window) {
            // Cancel any ongoing speech
            speechSynthesis.cancel();
            
            // Get all available voices
            const voices = speechSynthesis.getVoices();
            
            // Filter for Japanese voices and prefer female voices
            const japaneseVoices = voices.filter(voice => voice.lang.startsWith('ja'));
            
            let selectedVoice = null;
            
            // Prefer voices with female-sounding names or better quality indicators
            const femaleVoiceNames = ['kyoko', 'haruka', 'sayaka', 'yuki', 'female'];
            const highQualityNames = ['premium', 'enhanced', 'neural'];
            
            // First, try to find a high-quality female Japanese voice
            selectedVoice = japaneseVoices.find(voice => 
                femaleVoiceNames.some(name => voice.name.toLowerCase().includes(name)) ||
                highQualityNames.some(name => voice.name.toLowerCase().includes(name))
            );
            
            // If no preferred voice found, use the first Japanese voice available
            if (!selectedVoice && japaneseVoices.length > 0) {
                selectedVoice = japaneseVoices[0];
            }
            
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'ja-JP';
            utterance.rate = 0.8;
            
            // Use the selected voice if found
            if (selectedVoice) {
                utterance.voice = preferredVoice || selectedVoice;
            }
            
            utterance.onerror = function(event) {
                console.log('Speech synthesis error:', event);
            };
            
            speechSynthesis.speak(utterance);
        } else {
            console.log('Speech synthesis not supported');
        }
    } catch (error) {
        console.log('Error in speech synthesis:', error);
    }
}
// Preload voices to fix first-click voice bug
let preferredVoice = null;

function preloadVoices() {
    const voices = speechSynthesis.getVoices();
    const japaneseVoices = voices.filter(voice => voice.lang.startsWith('ja'));
    
    if (japaneseVoices.length > 0) {
        const femaleVoiceNames = ['kyoko', 'haruka', 'sayaka', 'yuki', 'female'];
        const highQualityNames = ['premium', 'enhanced', 'neural'];
        
        preferredVoice = japaneseVoices.find(voice =>
            femaleVoiceNames.some(name => voice.name.toLowerCase().includes(name)) ||
            highQualityNames.some(name => voice.name.toLowerCase().includes(name))
        );
        
        if (!preferredVoice) {
            preferredVoice = japaneseVoices[0];
        }
    }
}

// Load voices when available
speechSynthesis.addEventListener('voiceschanged', preloadVoices);
preloadVoices(); // Try immediately
        // Speech recognition for practice
        function startSpeechPractice(targetText, postElement) {
            try {
                if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    const recognition = new SpeechRecognition();
                    
                    recognition.lang = 'ja-JP';
                    recognition.continuous = false;
                    recognition.interimResults = false;

                    recognition.onstart = function() {
                        showVoiceFeedback(postElement, "Listening... Speak now!", "info");
                    };

                    recognition.onresult = function(event) {
                        try {
                            const spokenText = event.results[0][0].transcript;
                            
                            // Simple comparison (in real app, you'd want more sophisticated matching)
                            if (spokenText.includes(targetText.replace(/[！。]/g, ''))) {
                                showVoiceFeedback(postElement, "Great pronunciation! 👍", "success");
                                updateStats('practiced');
                            } else {
                                showVoiceFeedback(postElement, `You said: "${spokenText}". Try again!`, "error");
                            }
                        } catch (error) {
                            showVoiceFeedback(postElement, "Error processing speech. Try again!", "error");
                        }
                    };

                    recognition.onerror = function(event) {
                        showVoiceFeedback(postElement, "Speech recognition error. Try again!", "error");
                        console.log('Speech recognition error:', event.error);
                    };

                    recognition.start();
                } else {
                    showVoiceFeedback(postElement, "Speech recognition not supported in this browser", "error");
                }
            } catch (error) {
                showVoiceFeedback(postElement, "Error starting speech recognition", "error");
                console.log('Error in speech recognition:', error);
            }
        }

        function showVoiceFeedback(postElement, message, type) {
            let feedback = postElement.querySelector('.voice-feedback');
            if (!feedback) {
                feedback = document.createElement('div');
                feedback.className = 'voice-feedback';
                postElement.appendChild(feedback);
            }
            
            feedback.textContent = message;
            feedback.className = `voice-feedback ${type}`;
            
            setTimeout(() => {
                feedback.style.opacity = '0';
                setTimeout(() => {
                    if (feedback.parentNode) {
                        feedback.parentNode.removeChild(feedback);
                    }
                }, 300);
            }, 3000);
        }

        function revealAudioFirstText(button) {
            const post = button.closest('.post');
            const japaneseText = post.querySelector('.japanese-text');
            const audioFirstBtn = post.querySelector('.btn-audio-first');
            
            if (japaneseText.classList.contains('revealed')) {
                // Hide text (blur it again)
                japaneseText.classList.remove('revealed');
                audioFirstBtn.textContent = '👁️ Show Text';
            } else {
                // Show text (remove blur)
                japaneseText.classList.add('revealed');
                audioFirstBtn.textContent = '🙈 Hide Text';
            }
        }

        function revealTranslation(button) {
            const post = button.closest('.post');
            const translation = post.querySelector('.translation');
            const revealBtn = post.querySelector('.btn-reveal');
            
            if (translation.classList.contains('hidden')) {
                // Show translation
                translation.classList.remove('hidden');
                translation.classList.add('revealed');
                revealBtn.textContent = '🙈 Hide Translation';
            } else {
                // Hide translation
                translation.classList.add('hidden');
                translation.classList.remove('revealed');
                revealBtn.textContent = '💡 Show Translation';
            }
        }

        function showExplanation(button) {
            const post = button.closest('.post');
            const explanation = post.querySelector('.explanation');
            const explainBtn = post.querySelector('.btn-explain');
            
            if (explanation.classList.contains('hidden')) {
                // Show explanation
                explanation.classList.remove('hidden');
                explainBtn.textContent = '🔽 Hide Explanation';
            } else {
                // Hide explanation
                explanation.classList.add('hidden');
                explainBtn.textContent = '❓ Explain';
            }
        }

        function updateStats(action) {
            if (action === 'known') {
                knownCount++;
                document.getElementById('knownCount').textContent = knownCount;
            } else if (action === 'practiced') {
                practicedCount++;
                document.getElementById('practicedCount').textContent = practicedCount;
            }
        }

        function createPost(postData) {
            const postId = postData._id || postData.id || Math.random().toString(36).substr(2, 9);
            const post = document.createElement('div');
            
            let postClasses = 'post';
            if (postData.audioFirst) postClasses += ' audio-first';
            if (postData.exerciseType === 'recognition') postClasses += ' recognition-challenge';
            if (postData.exerciseType === 'phonetic') postClasses += ' phonetic-challenge';
            
            post.className = postClasses;
            
            let audioFirstHint = '';
            let audioFirstButton = '';
            if (postData.audioFirst) {
                audioFirstHint = '<div class="audio-first-hint">🎧 Listen first! Click the speaker, then reveal the text.</div>';
                audioFirstButton = '                    <button class="btn btn-audio-first" onclick="revealAudioFirstText(this)">👁️ Show Text</button>';
            }
            
            post.innerHTML = `
                <div class="post-type">${postData.type}</div>
                ${audioFirstHint}
                <div class="japanese-text">${postData.japanese}</div>
                ${postData.reading && postData.reading !== postData.japanese ? `<div class="reading">${postData.reading}</div>` : ''}
                <div class="translation hidden" id="translation-${postId}">${postData.translation}</div>
                <div class="explanation hidden" id="explanation-${postId}">
                    <strong>Grammar Notes:</strong><br>
                    ${postData.explanation || 'Basic sentence structure. Try breaking it down word by word.'}
                </div>
                <div class="actions">
                    <button class="btn btn-speak" onclick="speakJapanese('${postData.japanese}')">🔊 Listen</button>
                    ${audioFirstButton}
                    <button class="btn btn-practice" onclick="startSpeechPractice('${postData.japanese}', this.parentElement.parentElement)">🎤 Practice</button>
                    <button class="btn btn-reveal" onclick="revealTranslation(this)">💡 Show Translation</button>
                    <button class="btn btn-explain" onclick="showExplanation(this)">❓ Explain</button>
                    <button class="btn btn-know" onclick="markAsKnown(this)">✓ I Know This</button>
                    <button class="btn btn-difficult" onclick="markAsDifficult(this)">⚠ Review Later</button>
                </div>
            `;
            
            return post;
        }

        function markAsKnown(button) {
            const post = button.closest('.post');
            post.style.opacity = '0.7';
            post.style.border = '2px solid #48dbfb';
            updateStats('known');
            
            setTimeout(() => {
                loadNextPost();
            }, 1000);
        }

        function markAsDifficult(button) {
            const post = button.closest('.post');
            post.style.border = '2px solid #ff6b6b';
            // In a real app, this would add to a review queue
            
            setTimeout(() => {
                loadNextPost();
            }, 1000);
        }

        function loadNextPost() {
    const feed = document.getElementById('feed');
    
    const nextPost = getNextPost();
    if (nextPost) {
        const newPost = createPost(nextPost);
        feed.appendChild(newPost);
        
        // Keep only last 3 posts visible to avoid clutter
        const posts = feed.querySelectorAll('.post');
        if (posts.length > 3) {
            posts[0].style.transition = 'all 0.3s ease';
            posts[0].style.opacity = '0';
            posts[0].style.transform = 'translateY(-20px)';
            setTimeout(() => {
                if (posts[0].parentNode) {
                    posts[0].parentNode.removeChild(posts[0]);
                }
            }, 300);
        }
    } else {
        // Reset for demo purposes (shouldn't happen with our new system)
        console.log('No more posts available');
        loadNextPost();
    }
}

        // Initialize the app
async function initApp() {
    await fetchPosts();  // Add this line
    loadNextPost();
    
    // Load next post every 30 seconds for demo
    setInterval(() => {
        if (document.querySelectorAll('.post').length < 2) {
            loadNextPost();
        }
    }, 30000);
}

        // Start the app
        initApp();
    </script>
</body>
</html>
